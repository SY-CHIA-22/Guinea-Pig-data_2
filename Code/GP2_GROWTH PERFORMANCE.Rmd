---
title: "Guinea Pig Growth Analysis"
author: "Dr. Shaphan Yong Chia"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo       = TRUE,   # show code
  warning    = FALSE,  # hide warnings in output
  message    = FALSE,  # hide package loading messages
  fig.align  = "center",
  fig.width  = 7,
  fig.height = 5
)

# R Markdown

# This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>

# When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.

# i - renv package

```


# renv

```{r}

#Install the renv package by running the following command:
install.packages("renv")
library(renv)

#Set up renv for your project by navigating to your project's directory in R and running:
  
  renv::init()

#This will create a new .Rprofile file and an renv folder in your project directory.

renv::snapshot()

```

## =========================================================
## 0) Packages (robust install + load)
## =========================================================
pkgs <- c(
  "tidyverse","readxl","janitor","car","rstatix","ggpubr",
  "ARTool","emmeans","multcompView"
)

to_install <- pkgs[!pkgs %in% rownames(installed.packages())]
if(length(to_install) > 0) install.packages(to_install)

invisible(lapply(pkgs, library, character.only = TRUE))


## =========================================================
## 1) Import + clean
## =========================================================
dat <- read_excel("C:/Guinea-Pig-data_2/Data/GP2_INITIAL_WEIGHT.xlsx") %>%
  clean_names()

# --- enforce expected columns early (fail fast with a clear message)
needed <- c("diet","sex","ini_weight")
missed <- setdiff(needed, names(dat))
if(length(missed) > 0){
  stop("Missing required columns: ", paste(missed, collapse = ", "))
}

dat <- dat %>%
  mutate(
    diet       = factor(diet),
    sex        = factor(sex),
    ini_weight = suppressWarnings(as.numeric(ini_weight))
  ) %>%
  filter(!is.na(diet), !is.na(sex), !is.na(ini_weight))


glimpse(dat)
summary(dat)


## =========================================================
## 2) Baseline check: 2-way ANOVA diagnostics
## =========================================================
mod_ini <- aov(ini_weight ~ diet * sex, data = dat)

res <- residuals(mod_ini)

shapiro_test <- shapiro.test(res)
levene_test  <- car::leveneTest(ini_weight ~ interaction(diet, sex), data = dat)

print(summary(mod_ini))
print(shapiro_test)
print(levene_test)

# QQ plot
p_qq <- ggplot(data.frame(res = res), aes(sample = res)) +
  stat_qq() +
  stat_qq_line() +
  labs(title = "QQ-Plot of ANOVA Residuals",
       x = "Theoretical Quantiles", y = "Sample Quantiles") +
  theme_bw()
p_qq


## =========================================================
## 3) Decide analysis route
##    - If assumptions OK: use ANOVA + emmeans
##    - If not: use ART (Aligned Rank Transform) factorial ANOVA
## =========================================================

## =========================================================
## Use ART ANOVA when Levene is significant (your case)
## (keep the ANOVA branch only if you truly want it)
## =========================================================

# robust extraction of Levene p-value (works even if column name differs)
lev_p <- as.numeric(levene_test[["Pr(>F)"]][1])

assumptions_ok <- (shapiro_test$p.value > 0.05) && (lev_p > 0.05)

if (assumptions_ok) {

  message("Assumptions look OK -> using 2-way ANOVA + emmeans.")
  fit_used <- "ANOVA"

  anova_tab <- anova(mod_ini)
  print(anova_tab)

  # Diet comparisons within each sex
  emm <- emmeans::emmeans(mod_ini, ~ diet | sex)
  print(emm)
  print(pairs(emm, adjust = "tukey"))

  # OPTIONAL: test simple effects / interaction contrasts
  # emm_int <- emmeans::emmeans(mod_ini, ~ diet * sex)
  # print(pairs(emm_int, by = "sex", adjust = "tukey"))

} else {

  message("Assumptions violated -> using ART (Aligned Rank Transform) factorial ANOVA.")
  fit_used <- "ART"

  # 1) Fit ART model
  mod_art <- ARTool::art(ini_weight ~ diet * sex, data = dat)

  # 2) ART ANOVA table (main + interaction)
  anova_tab <- anova(mod_art)
  print(anova_tab)

  # 3) Post-hoc: Diet differences WITHIN each sex (simple effects)
  #    Use the aligned model for the DIET effect, then apply emmeans with by = sex
  art_diet <- ARTool::artlm(mod_art, "diet")

  emm <- emmeans::emmeans(art_diet, ~ diet | sex)
  print(emm)
  print(pairs(emm, adjust = "tukey"))
}

## =========================================================
## 5) Compact letter display (diet differences within each sex)
##    Uses Dunn p.adj (robust matrix built from present diet levels).
## =========================================================
make_letters_from_dunn <- function(df_sex, dunn_tbl){
  levs <- levels(droplevels(df_sex$diet))
  if(length(levs) < 2) return(tibble(diet = factor(levs, levels = levs), letter = ""))

  # initialize p-matrix with 1's
  pmat <- matrix(1, nrow = length(levs), ncol = length(levs),
                 dimnames = list(levs, levs))

  if(nrow(dunn_tbl) > 0){
    for(i in seq_len(nrow(dunn_tbl))){
      g1 <- as.character(dunn_tbl$group1[i])
      g2 <- as.character(dunn_tbl$group2[i])
      p  <- dunn_tbl$p.adj[i]
      if(g1 %in% levs && g2 %in% levs){
        pmat[g1, g2] <- p
        pmat[g2, g1] <- p
      }
    }
  }

  tibble(
    diet   = factor(names(multcompView::multcompLetters(pmat)$Letters), levels = levs),
    letter = unname(multcompView::multcompLetters(pmat)$Letters)
  )
}

letters_all <- dat %>%
  group_by(sex) %>%
  group_modify(~{
    dunn_tbl <- rstatix::dunn_test(.x, ini_weight ~ diet, p.adjust.method = "bonferroni")
    make_letters_from_dunn(.x, dunn_tbl)
  }) %>%
  ungroup()

# letter positions
pos_all <- dat %>%
  group_by(sex, diet) %>%
  summarise(ymax = max(ini_weight, na.rm = TRUE), .groups = "drop") %>%
  left_join(letters_all, by = c("sex","diet"))

# N per group
n_all <- dat %>%
  group_by(sex, diet) %>%
  summarise(n = n(), .groups = "drop")

# global range for neat offsets
global_min   <- min(dat$ini_weight, na.rm = TRUE)
global_max   <- max(dat$ini_weight, na.rm = TRUE)
global_range <- global_max - global_min

sex_means <- dat %>%
  group_by(sex) %>%
  summarise(mean_init = mean(ini_weight, na.rm = TRUE), .groups = "drop")


## =========================================================
## 6) Journal-ready figure (faceted by sex)

## =========================================================
## Clean publication plot (NO stats text, NO n labels)
## - bigger bottom padding so violins/boxes don't touch x-axis
## - keep sex-specific dotted reference lines
## - keep letters (optional; remove that layer if you don't want letters)
## =========================================================

# ---- 1) Colour palette (Okabe–Ito; colour-blind friendly)
okabe_ito <- c("#0072B2", "#009E73", "#D55E00", "#CC79A7", "#56B4E9", "#E69F00")
diet_levels <- levels(dat$diet)
diet_cols <- setNames(okabe_ito[seq_along(diet_levels)], diet_levels)

# ---- 2) Padding so geoms do NOT touch x-axis (axis still starts at 0)
global_max <- max(dat$ini_weight, na.rm = TRUE)

# Increase this to increase the visible "air" above the x-axis
bottom_pad_frac <- 0.06   # try 0.12–0.20 (bigger = more air)
top_pad_frac    <- 0.22   # room for letters above the violins

y_min_plot <- 0
y_max_plot <- global_max * (1 + top_pad_frac)

# This creates a visible gap between y=0 axis and the lowest data/violin
# while still starting the axis at 0.
y_expand_mult_lower <- bottom_pad_frac
y_expand_mult_upper <- 0.03

# Letter vertical offset
letter_y_offset <- 0.05 * global_max
pos_all2 <- pos_all %>%
  dplyr::mutate(y_letter = ymax + letter_y_offset)

# ---- 3) The figure
p_final <- ggplot(dat, aes(x = diet, y = ini_weight, fill = diet)) +
  
  ## Sex-specific horizontal reference lines (mean initial weight per sex)
  geom_hline(
    data = sex_means,
    aes(yintercept = mean_init),
    linetype = "dotted",
    colour = "grey35",
    linewidth = 0.6
  ) +
  
  # violins: colourful + clean outline
  geom_violin(
    trim = FALSE,
    alpha = 0.45,
    colour = "black",
    linewidth = 0.55
  ) +
  
  # boxplots: crisp, narrow, on top
  geom_boxplot(
    width = 0.14,
    outlier.shape = NA,
    fill = "white",
    colour = "black",
    linewidth = 0.65
  ) +
  
  # individual points (subtle, not dominating)
  geom_jitter(
    aes(colour = diet),
    width = 0.10,
    height = 0,
    alpha = 0.45,
    size  = 1.6,
    show.legend = FALSE
  ) +
  
  # mean diamonds (high-contrast)
  stat_summary(
    fun = mean,
    geom = "point",
    shape = 23,
    size = 3.6,
    fill = "black",
    colour = "white",
    stroke = 0.7,
    show.legend = FALSE
  ) +
  
  # significance letters (keep if you want; remove this layer if not needed)
  geom_text(
    data = pos_all2,
    aes(x = diet, y = y_letter, label = letter),
    inherit.aes = FALSE,
    fontface = "bold",
    size = 4.2
  ) +
  
  facet_wrap(~ sex, nrow = 1) +
  
  scale_fill_manual(values = diet_cols) +
  scale_colour_manual(values = diet_cols) +
  
  # Start axis at 0 + add padding via "expand" (keeps 0 visible, adds air)
  scale_y_continuous(
    limits = c(y_min_plot, y_max_plot),
    expand = expansion(mult = c(y_expand_mult_lower, y_expand_mult_upper))
  ) +
  
  labs(
    x = "Diet",
    y = "Initial body weight (g)"
  ) +
  
  theme_classic(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    plot.title = element_blank(),
    strip.background = element_rect(fill = "white", colour = "black", linewidth = 0.6),
    strip.text = element_text(face = "bold", size = 13),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text = element_text(colour = "black"),
    legend.position = "none"
  )

p_final

#Export 
ggsave(
  filename = "Initial_Weight_Baseline_ART.pdf",
  plot     = p_final,
  device   = cairo_pdf,     # best text rendering
  width    = 18,            # cm (≈ 7.1 inches)
  height   = 10,            # cm (≈ 3.9 inches)
  units    = "cm"
)




# 4. ################# Feed intake #######################


library(readxl)
library(janitor)
setwd("C:/Guinea-Pig-data_2/Data")

dat_feed <- read_excel("GP2_Feedintake.xlsx") %>%
  clean_names()

glimpse(dat_feed)

###### summary
summary_adfi <- dat_feed %>%
  group_by(diet, sex) %>%
  summarise(
    mean_adfi = mean(adfi, na.rm = TRUE),
    sd_adfi   = sd(adfi, na.rm = TRUE),
    n         = n(),
    .groups   = "drop"
  )
summary_adfi

# Convert to correct formats
dat_feed <- dat_feed %>%
  mutate(
    diet        = factor(diet),          # T1, T2, T3, T4
    compartment = factor(compartment),   # Compartment IDs
    animals     = as.numeric(animals),   # Number of animals
    sex         = factor(sex),           # F or M
    adfi = as.numeric(adfi)  # Daily intake per animal
  )

## check for normality
res <- residuals(aov(adfi ~ diet * sex, data = dat_feed))
shapiro.test(res) # violated

#homogeneity of varance
car::leveneTest(adfi ~ diet * sex, data = dat_feed) # voilated


#therefore, use ART TEST
mod_art_adfi <- art(adfi ~ diet * sex, data = dat_feed)
anova(mod_art_adfi)

#1: emmeans for the interaction
library(emmeans)
library(multcompView)
library(dplyr)
library(tidyr)

emm_inter <- emmeans(
  artlm(mod_art_adfi, "diet:sex"),
  ~ diet:sex
)

emm_inter

#2: Compact letter display (significance letters)
library(emmeans)
emmeans::cld


library(multcomp)

letters_inter <- multcomp::cld(
  emm_inter,
  level   = 0.05,
  Letters = letters,
  adjust  = "sidak"
)

# compare levels of diet within each level of sex
## Estimated marginal means
emm_inter <- emmeans(artlm(mod_art_adfi, "diet:sex"), ~ diet | sex)

## Pairwise comparisons per sex
pairs_inter <- contrast(emm_inter, method = "pairwise", adjust = "tukey")
pairs_inter


## Significance letters within each sex
library(multcomp)

letters_within <- multcomp::cld(
  emm_inter,
  level   = 0.05,
  Letters = letters,
  adjust  = "tukey"
)
letters_within

############################################# plot feed intake

# Convert to plain data frame
lf <- as.data.frame(letters_within)

# Inspect column names once (optional, just to see them)
names(lf)


# Automatically detect the relevant columns
diet_col   <- grep("diet",   names(lf), ignore.case = TRUE, value = TRUE)[1]
sex_col    <- grep("sex",    names(lf), ignore.case = TRUE, value = TRUE)[1]
letter_col <- grep("group|letters", names(lf), ignore.case = TRUE, value = TRUE)[1]

# Subset and rename
letters_df <- lf[, c(diet_col, sex_col, letter_col)]
names(letters_df) <- c("diet", "sex", "letter")

# Make sure diet and sex are factors
letters_df$diet <- as.factor(letters_df$diet)
letters_df$sex  <- as.factor(letters_df$sex)

letters_df


### Build pos_all for plotting
library(dplyr)

pos_all <- dat_feed %>%
  group_by(diet, sex) %>%
  summarise(
    ymax = max(adfi, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  left_join(letters_df, by = c("diet", "sex"))

pos_all

### Global range for letter placement

global_min   <- min(dat_feed$adfi, na.rm = TRUE)
global_max   <- max(dat_feed$adfi, na.rm = TRUE)
global_range <- global_max - global_min


### Final journal-ready plot with letters
library(ggplot2)

ggplot(dat_feed, aes(x = diet, y = adfi)) +
  
  # Violin: soft teal
  geom_violin(
    fill      = "#9AD3CA",
    colour    = "#2A776C",
    trim      = FALSE,
    alpha     = 0.9,
    linewidth = 0.7
  ) +
  
  # Boxplot
  geom_boxplot(
    width         = 0.12,
    outlier.shape = NA,
    fill          = "white",
    colour        = "black",
    linewidth     = 0.7
  ) +
  
  # Mean diamond
  stat_summary(
    fun    = mean,
    geom   = "point",
    shape  = 23,
    size   = 3.8,
    fill   = "#2A776C",
    colour = "white",
    stroke = 0.9
  ) +
  
  # ART-Tukey significance letters
  geom_text(
    data        = pos_all,
    aes(x = diet, y = ymax + 0.06 * global_range, label = letter),
    inherit.aes = FALSE,
    fontface    = "bold",
    size        = 4
  ) +
  
  facet_wrap(~ sex, nrow = 1) +
  
  labs(
    title = "Average Daily Feed Intake per Animal by Diet and Sex",
    x     = "Diet",
    y     = "ADFI (g/day per animal)"
  ) +
  
  # FORCE y-axis to start at zero
  expand_limits(y = 0) +
  
  theme_bw(base_size = 14) +
  theme(
    plot.title   = element_text(face = "bold", size = 16, hjust = 0.5),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold"),
    axis.text    = element_text(colour = "black"),
    strip.text   = element_text(face = "bold", size = 14),
    panel.grid   = element_blank(),
    panel.border = element_rect(colour = "black", linewidth = 0.8),
    legend.position = "none"
  )

### summary table 
library(dplyr)

adfi_summary <- dat_feed %>%
  group_by(diet, sex) %>%
  summarise(
    n         = n(),
    mean_ADFI = mean(adfi, na.rm = TRUE),
    sd_ADFI   = sd(adfi, na.rm = TRUE),
    sem_ADFI  = sd(adfi, na.rm = TRUE) / sqrt(n()),
    .groups   = "drop"
  )

adfi_summary